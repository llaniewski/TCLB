#include <stdlib.h>
#include <cstring>
#include <iostream>
#include "pugixml.hpp"
#include "Consts.h"
#include "cross.h"
#include "types.h"
#include "Region.h"
#include "Geometry.h"
#include "Global.h"
#include "def.h"
#include "vtkOutput.h"
#include "utils.h"
#include <assert.h>

/// Main constructor
/**
        Constructs the Geometry object based on size
        \param r Global Lattice region
        \param units_ Units object associated with the this Geometry object
*/
Geometry::Geometry(const lbRegion & r, const UnitEnv & units_):region(r), units(units_)
{
    geom = new flag_t[region.sizeL()];
	q100= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q200= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q010= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q110= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q210= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q020= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q120= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q220= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q001= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q101= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q201= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q011= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q111= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q211= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q021= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q121= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q221= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q002= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q102= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q202= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q012= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q112= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q212= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q022= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q122= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  
        q222= (unsigned char*) malloc(region.sizeL()*sizeof(unsigned char));  

    for (size_t i = 0; i < region.sizeL(); i++) {
	geom[i] = 0;
	    //qibb 255 stands for not active direction
	q100[i] = 255; 
        q200[i] = 255; 
        q010[i] = 255; 
        q110[i] = 255; 
        q210[i] = 255; 
        q020[i] = 255; 
        q120[i] = 255; 
        q220[i] = 255; 
        q001[i] = 255; 
        q101[i] = 255; 
        q201[i] = 255; 
        q011[i] = 255; 
        q111[i] = 255; 
        q211[i] = 255; 
        q021[i] = 255; 
        q121[i] = 255; 
        q221[i] = 255; 
        q002[i] = 255; 
        q102[i] = 255; 
        q202[i] = 255; 
        q012[i] = 255; 
        q112[i] = 255; 
        q212[i] = 255; 
        q022[i] = 255; 
        q122[i] = 255; 
        q222[i] = 255; 
    }
    
    output("Creating geom size:%ld\n", region.sizeL());
    SettingZones["DefaultZone"] = 0;
}

#define E(x) if (x) { return -1; }

/// Return rounded unit-free value of an xml attribute
/**
        Get the value of an xml attribute, calculate the units
        and round the result to full integer
        \param attr XML attribute
        \param def Default value to return in case there is no such attribute
*/
int Geometry::val(pugi::xml_attribute attr, int def)
{
    if (!attr) {
	return def;
    } else {
	return myround(units.alt(attr.value(), def));
    }
}

/// Return rounded unit-free value of an xml attribute (with no default)
/**
        Get the value of an xml attribute, calculate the units
        and round the result to full integer. Print error when no default.
        \param attr XML attribute
*/
int Geometry::val(pugi::xml_attribute attr)
{
    if (!attr) {
	error("Attribute without value and default\n");
	return -1;
    }
    return myround(units.alt(attr.value()));
}
/// Return rounded unit-free value of an xml attribute, extract first char as prefix 
/**
        Get the value of an xml attribute, calculate the units
        and round the result to full integer. Print error when no default.
        \param attr XML attribute
*/
int Geometry::val_p(pugi::xml_attribute attr, char* prefix)
{
    if (!attr) {
    error("Attribute without value and default\n");
    return -1;
    }
    std::string tmp = attr.value();
    *prefix = tmp[0];
    if (*prefix == '>' || *prefix == '<'){
        tmp = tmp.substr(1);
    } else {
        *prefix = '+';
    }
    return myround(units.alt(tmp));
}


/// Return unit-free value of an xml attribute
double Geometry::val_d(pugi::xml_attribute attr)
{
    return units.alt(attr.value());
}

/// Set the foreground flag/NodeType
/**
        Set the foreground flag, which will be used to fill
        all the geometry primitives later on.
        \param name Name of the flag/NodeType to set
*/
int Geometry::setFlag(const pugi::char_t * name)
{
    pugi::xml_node node = fg_xml.find_child_by_attribute("Type", "name", name);
    if (!node) {
	ERROR("Unknown flag (in xml): %s\n", name);
	return -1;
    }
    fg = node.attribute("value").as_int();
    E(setMask(node.attribute("mask").value()));
    return 0;
}

/// Set the forground flag mask
/**
        Set the foreground flag mask, which will be used to
        mask what is overwriten when filling with foreground flag
        in all the geometry primitives later on.
        \param name Name of the flag mask/NodeType to set
*/
int Geometry::setMask(const pugi::char_t * name)
{
    pugi::xml_node node = fg_xml.find_child_by_attribute("Mask", "name", name);
    if (!node) {
	error("Unknown mask (in xml): %s\n", name);
	return -1;
    }
    fg_mask = node.attribute("value").as_int(-1);
    return 0;
}

int Geometry::setZone(const pugi::char_t * name)
{
    int ZoneNumber;
    if (SettingZones.count(name) > 0) {
        ZoneNumber = SettingZones[name];
    } else {
        ZoneNumber = SettingZones.size();
        debug1("Setting new zone: %s -> %d\n", name, ZoneNumber);
        SettingZones[name] = ZoneNumber;
    }
    assert(ZoneNumber < ZONE_MAX);
    fg      = (fg      &(~ NODE_SETTINGZONE )) |  (ZoneNumber << ZONE_SHIFT);
    fg_mask =  fg_mask |   NODE_SETTINGZONE;
    return 0;
}

#define MAX_INT 2e9;

/// Sets a region according to the XML attributes
/**
        Sets a region with respect to the parent region basing
        on XML attributes like "nx","dx" and "dx"
        \param node XML element
*/
lbRegion Geometry::getRegion(const pugi::xml_node & node)
{
    lbRegion ret;
    pugi::xml_attribute attr;
    if (!node) {
	ret.dx = ret.dy = ret.dz = 0;
	ret.nx = ret.ny = ret.nz = 1;
	return ret;
    }
    ret = getRegion(node.parent());

    char side; 
    
    attr = node.attribute("dx");
    if (attr) {
	int w = val_p(attr, &side);
    
    if (side == '<') {
        w = ret.nx + w;
    } else if (side == '+') {
    	if (w < 0)
	        w = ret.nx + w;
    }

	ret.dx += w;
	ret.nx -= w;
    }
    attr = node.attribute("dy");
    if (attr) {
	int w = val_p(attr, &side);

    if (side == '<') {
        w = ret.ny + w;
    } else if (side == '+') {
    	if (w < 0)
	        w = ret.ny + w;
    }

	ret.dy += w;
	ret.ny -= w;
    }
    attr = node.attribute("dz");
    if (attr) {
	int w = val_p(attr, &side);
    if (side == '<') {
        w = ret.nz + w;
    } else if (side == '+') {
    	if (w < 0)
	        w = ret.nz + w;
    }
	ret.dz += w;
	ret.nz -= w;
    }

    attr = node.attribute("fx");
    if (attr) {
	int w = val(attr);
	if (w < 0)
	    w = ret.nx + w + ret.dx;
	ret.nx = w - ret.dx + 1;
    }
    attr = node.attribute("fy");
    if (attr) {
	int w = val(attr);
	if (w < 0)
	    w = ret.ny + w + ret.dy;
	ret.ny = w - ret.dy + 1;
    }
    attr = node.attribute("fz");
    if (attr) {
	int w = val(attr);
	if (w < 0)
	    w = ret.nz + w + ret.dz;
	ret.nz = w - ret.dz + 1;
    }

    attr = node.attribute("nx");
    if (attr)
	ret.nx = val(attr);
    attr = node.attribute("ny");
    if (attr)
	ret.ny = val(attr);
    attr = node.attribute("nz");
    if (attr)
	ret.nz = val(attr);

    return ret;
}

/// Fill a node with foreground flag
inline flag_t Geometry::Dot(int x, int y, int z)
{
    if (region.isIn(x, y, z)) {
	int i = region.offset(x, y, z);
	return geom[i] = (geom[i] & (~fg_mask)) | fg;
    } else 
    return NODE_None;
}

/// Fill a node with foreground flag
inline flag_t Geometry::QibbDot(LBMdataQ26 data)
{
	
	int x = data.p[0];
	int y = data.p[1];
	int z = data.p[2];
	
    if (region.isIn(x, y, z)){
	int i = region.offset(x, y, z);
	q100[i] = data.q26[0];
	q010[i] = data.q26[1];
	q200[i] = data.q26[2];
	q020[i] = data.q26[3];
	q001[i] = data.q26[4];
	q002[i] = data.q26[5];
	q110[i] = data.q26[6];
	q210[i] = data.q26[7];
	q220[i] = data.q26[8];
	q120[i] = data.q26[9];
	q101[i] = data.q26[10];
	q011[i] = data.q26[11];
	q201[i] = data.q26[12];
	q021[i] = data.q26[13];
	q102[i] = data.q26[14];
	q012[i] = data.q26[15];
	q202[i] = data.q26[16];
	q022[i] = data.q26[17];
	q111[i] = data.q26[18];
	q211[i] = data.q26[19];
	q221[i] = data.q26[20];
	q121[i] = data.q26[21];
	q112[i] = data.q26[22];
	q212[i] = data.q26[23];
	q222[i] = data.q26[24];
	q122[i] = data.q26[25];
	return geom[i] = (geom[i] & (~fg_mask)) | NODE_QIBB; // I am not sure if that works...
	
    } else 
    return NODE_None;
    
}

/// Check if a point is inside a sphere
inline int inSphere(double x, double y, double z)
{
    x = 2 * x - 1;
    y = 2 * y - 1;
    z = 2 * z - 1;
    return (x * x + y * y + z * z) < 1;
}

/// Check if a point is inside of a wedge
inline int inWedge(double x, double y, double z, const char *type)
{
    if (strcmp(type, "") == 0)
	type = "UpperLeft";
    if (strcmp(type, "UpperLeft") == 0) {
	// default
    } else if (strcmp(type, "UpperRight") == 0) {
	x = 1. - x;
    } else if (strcmp(type, "LowerLeft") == 0) {
	y = 1. - y;
    } else if (strcmp(type, "LowerRight") == 0) {
	x = 1. - x;
	y = 1. - y;
    }
    return (x - y) < 1e-10;
}

/// Transform STL points according to attributes of an XML element
inline int Geometry::transformSTL(int ntri, STL_tri * tri, pugi::xml_node n)
{
    if (n.attribute("Xrot")) {
	double v = units.alt(n.attribute("Xrot").value());
	debug1("STL: rotating X axis %lf (%lf deg)\n", v, v / 4. / atan(1.) * 180);
	double y, z;
	for (int i = 0; i < ntri; i++) {
	    y = tri[i].p1[1];
	    z = tri[i].p1[2];
	    tri[i].p1[1] = cos(v) * y - sin(v) * z;
	    tri[i].p1[2] = sin(v) * y + cos(v) * z;
	    y = tri[i].p2[1];
	    z = tri[i].p2[2];
	    tri[i].p2[1] = cos(v) * y - sin(v) * z;
	    tri[i].p2[2] = sin(v) * y + cos(v) * z;
	    y = tri[i].p3[1];
	    z = tri[i].p3[2];
	    tri[i].p3[1] = cos(v) * y - sin(v) * z;
	    tri[i].p3[2] = sin(v) * y + cos(v) * z;
	}
    }
    if (n.attribute("scale")) {
	double v = units.alt(n.attribute("scale").value());
	debug1("STL: scaling %lf\n", v);
	for (int i = 0; i < ntri; i++) {
	    tri[i].p1[0] = v * tri[i].p1[0];
	    tri[i].p2[0] = v * tri[i].p2[0];
	    tri[i].p3[0] = v * tri[i].p3[0];
	    tri[i].p1[1] = v * tri[i].p1[1];
	    tri[i].p2[1] = v * tri[i].p2[1];
	    tri[i].p3[1] = v * tri[i].p3[1];
	    tri[i].p1[2] = v * tri[i].p1[2];
	    tri[i].p2[2] = v * tri[i].p2[2];
	    tri[i].p3[2] = v * tri[i].p3[2];
	}
    }
    if (n.attribute("x")) {
	double v = units.alt(n.attribute("x").value());
	debug1("STL: move in x %lf\n", v);
	for (int i = 0; i < ntri; i++) {
	    tri[i].p1[0] += v;
	    tri[i].p2[0] += v;
	    tri[i].p3[0] += v;
	}
    }
    if (n.attribute("y")) {
	double v = units.alt(n.attribute("y").value());
	debug1("STL: move in y %lf\n", v);
	for (int i = 0; i < ntri; i++) {
	    tri[i].p1[1] += v;
	    tri[i].p2[1] += v;
	    tri[i].p3[1] += v;
	}
    }
    if (n.attribute("z")) {
	double v = units.alt(n.attribute("z").value());
	debug1("STL: move in z %lf\n", v);
	for (int i = 0; i < ntri; i++) {
	    tri[i].p1[2] += v;
	    tri[i].p2[2] += v;
	    tri[i].p3[2] += v;
	}
    }
    for (int i = 0; i < ntri; i++) {
	for (int j = 0; j < 3; j++) {
		tri[i].p1[j] += 1e-7 - 0.5;
		tri[i].p2[j] += 1e-7 - 0.5;
		tri[i].p3[j] += 1e-7 - 0.5;
		tri[i].p1[j] = myround(tri[i].p1[j] * 1e5) * 1e-5;
		tri[i].p2[j] = myround(tri[i].p2[j] * 1e5) * 1e-5;
		tri[i].p3[j] = myround(tri[i].p3[j] * 1e5) * 1e-5;
	}
    }
    return 0;
}

/// Load STL file
inline int Geometry::loadSTL(lbRegion reg, pugi::xml_node n)
{
    char header[80];
    STL_tri *tri;
    int ntri;
    int ret;
    int insideOut=0;
    if (!n.attribute("file")) {
	error("No 'file' attribute in 'STL' element in xml conf\n");
	return -1;
    }
    if (n.attribute("side")) {
        std::string side=n.attribute("side").value();
        if (side == "in") {
	    insideOut=0;
        } else if (side == "out") {
            insideOut=1;
        } else {
	    error("'side' in 'STL' element have to be 'in' or 'out'\n");
	    return -1;
	}
    }
    debug1("------ STL -----\n");
    FILE *f = fopen(n.attribute("file").value(), "rb");
    if (f == NULL) {
	error("'STL' element: %s doesn't exists or cannot be opened\n", n.attribute("file").value());
	return -1;
    }
    ret = fread(header, 80, sizeof(char), f);
    ret = fread(&ntri, 1, sizeof(int), f);
    tri = (STL_tri *) malloc(ntri * sizeof(STL_tri));
    char *lev = (char *) malloc(reg.size() * sizeof(char));
    for (int i = 0; i < reg.size(); i++)
	lev[i] = insideOut;
    debug1("%d x %ld = %ld\n", ntri, sizeof(STL_tri), ntri * sizeof(STL_tri));
    ret = fread(tri, ntri, sizeof(STL_tri), f);
    fclose(f);

    debug1("Number of triangles: %d\n", ntri);
    transformSTL(ntri, tri, n);
    for (int i = 0; i < ntri; i++) {
	int minx, maxx, minz, maxz;
	minx = ceil(tri[i].p1[0]);
	if (tri[i].p2[0] < minx)
	    minx = ceil(tri[i].p2[0]);
	if (tri[i].p3[0] < minx)
	    minx = ceil(tri[i].p3[0]);
	maxx = floor(tri[i].p1[0]);
	if (tri[i].p2[0] > maxx)
	    maxx = floor(tri[i].p2[0]);
	if (tri[i].p3[0] > maxx)
	    maxx = floor(tri[i].p3[0]);
	minz = ceil(tri[i].p1[2]);
	if (tri[i].p2[2] < minz)
	    minz = ceil(tri[i].p2[2]);
	if (tri[i].p3[2] < minz)
	    minz = ceil(tri[i].p3[2]);
	maxz = floor(tri[i].p1[2]);
	if (tri[i].p2[2] > maxz)
	    maxz = floor(tri[i].p2[2]);
	if (tri[i].p3[2] > maxz)
	    maxz = floor(tri[i].p3[2]);
	double v[2], v1[2], v2[2], c0, c1, c2, c3;
	v1[0] = tri[i].p2[0] - tri[i].p1[0];
	v1[1] = tri[i].p2[2] - tri[i].p1[2];
	v2[0] = tri[i].p3[0] - tri[i].p1[0];
	v2[1] = tri[i].p3[2] - tri[i].p1[2];
	c0 = v1[0] * v2[1] - v1[1] * v2[0];
	for (int x = minx; x <= maxx; x++)
	    for (int z = minz; z <= maxz; z++) {
		v[0] = x - tri[i].p1[0];
		v[1] = z - tri[i].p1[2];
		c1 = v1[0] * v[1] - v1[1] * v[0];
		c2 = v[0] * v2[1] - v[1] * v2[0];
		c1 /= c0;
		c2 /= c0;
		if ((c1 >= 0) && (c2 >= 0) && (c1 + c2 <= 1)) {
		    c3 = 1. - c1 - c2;
		    double h = tri[i].p1[1] * c3 + tri[i].p2[1] * c2 + tri[i].p3[1] * c1;
		    for (int y = reg.dy; y <= h; y++) {
//                                        debug1("%d %d %d %d\n",x,y,z,reg.offset(x,y,z));
			if (reg.isIn(x, y, z))
			    lev[reg.offset(x, y, z)]++;
		    }
		}
	    }
    }
    for (int x = reg.dx; x < reg.dx + reg.nx; x++)
	for (int y = reg.dy; y < reg.dy + reg.ny; y++)
	    for (int z = reg.dz; z < reg.dz + reg.nz; z++) {
		if (lev[reg.offset(x, y, z)] % 2 == 1) {
//                        debug1("%d %d %d %d\n",x,y,z,lev[reg.offset(x,y,z)]);
		    Dot(x, y, z);
		}
	    }
    free(tri);
    free(lev);
    return 0;
}




/// Main geometry-generating function
int Geometry::Draw(pugi::xml_node & node)
{
    for (pugi::xml_node n = node.first_child(); n; n = n.next_sibling()) {
	lbRegion reg = getRegion(n);
	if (strcmp(n.name(), "Box") == 0) {
	    reg = region.intersect(reg);
	    debug1("Filling with flag %d (%d)\n", fg, fg_mask);
	    DEBUG1(reg.print();)
		for (int x = reg.dx; x < reg.dx + reg.nx; x++)
		for (int y = reg.dy; y < reg.dy + reg.ny; y++)
		    for (int z = reg.dz; z < reg.dz + reg.nz; z++) {
			Dot(x, y, z);
		    }
	} else if (strcmp(n.name(), "HalfSphere") == 0) {
//                      reg = region.intersect(reg);
	    debug1("Filling half sphere with flag %d (%d)\n", fg, fg_mask);
	    DEBUG1(reg.print();)
		for (int x = reg.dx; x < reg.dx + reg.nx; x++)
		for (int y = reg.dy; y < reg.dy + reg.ny; y++)
		    for (int z = reg.dz; z < reg.dz + reg.nz; z++) {
			if (inSphere((.5 + x - reg.dx) / reg.nx, 0.5 - (y - .5  - reg.dy) / reg.ny / 2., (.5 + z - reg.dz) / reg.nz) ) {
			    Dot(x, y, z);
			}
		    }
	} else if (strcmp(n.name(), "Sphere") == 0) {
//                      reg = region.intersect(reg);
	    debug1("Filling sphere with flag %d (%d)\n", fg, fg_mask);
	    DEBUG1(reg.print();)
		for (int x = reg.dx; x < reg.dx + reg.nx; x++)
		for (int y = reg.dy; y < reg.dy + reg.ny; y++)
		    for (int z = reg.dz; z < reg.dz + reg.nz; z++) {
			if (inSphere((.5 + x - reg.dx) / reg.nx, (.5 + y - reg.dy) / reg.ny, (.5 + z - reg.dz) / reg.nz)) {
			    Dot(x, y, z);
			}
		    }
	}    
    else if (strcmp(n.name(),"Pipe") == 0) {
	    debug1("Filling pipe with flag %d (&d)\n",fg,fg_mask);
	    DEBUG1(reg.print();)
            for (int x = reg.dx; x < reg.dx + reg.nx; x++)
		for (int y = reg.dy - 1 ; y < reg.dy + reg.ny + 1; y++)
		   for (int z = reg.dz - 1; z < reg.dz + reg.nz + 1;z++) {
			 if (!inSphere(0.5, (.5 + y - reg.dy) / reg.ny, (.5 + z - reg.dz) / reg.nz)) {
				Dot(x,y,z);
			}
		   }
	} 
    else if (strcmp(n.name(), "Wedge") == 0) {
//                      reg = region.intersect(reg);
	    debug1("Filling wedge with flag %d (%d)\n", fg, fg_mask);
	    DEBUG1(reg.print();)
	    const char *type = n.attribute("direction").value();
	    for (int x = reg.dx; x < reg.dx + reg.nx; x++)
		for (int y = reg.dy; y < reg.dy + reg.ny; y++)
		    for (int z = reg.dz; z < reg.dz + reg.nz; z++) {
			if (inWedge((x - reg.dx) / (reg.nx - 1.), (y - reg.dy) / (reg.ny - 1.), (z - reg.dz) / (reg.nz - 1.), type)) {
			    Dot(x, y, z);
			}
		    }
	} else if (strcmp(n.name(), "STL") == 0) {
	    debug1("Filling stl geometry with flag %d (%d)\n", fg, fg_mask);
	    DEBUG1(reg.print();)
		if (loadSTL(reg, n))
		return -1;
	}
	else if (strcmp(n.name(), "QIBB") == 0){
		debug1("  [QIBB] Reading QIBB data\n");
		output("  [QIBB] Reading QIBB data\n");
		if (loadQIBBdata(reg, n))
		return -1;
	}
	else if (strcmp(n.name(), "Text") == 0) {
	    lbRegion crop = getRegion(n.parent());
	    crop = region.intersect(crop);
	    crop.print();
	    if (!n.attribute("file")) {
		error("No 'file' attribute in 'Text' element in xml conf\n");
		return -1;
	    }
	    FILE *f = fopen(n.attribute("file").value(), "rt");
	    if (f == NULL) {
		error("Could not open file: %s\n", n.attribute("file").value());
		return -1;
	    }
	    output("Reading file %s\n", n.attribute("file").value());
	    for (int x = reg.dx; x < reg.dx + reg.nx; x++)
		for (int y = reg.dy; y < reg.dy + reg.ny; y++)
		    for (int z = reg.dz; z < reg.dz + reg.nz; z++) {
			int v;
			int ret = fscanf(f, "%d", &v);
                        if (ret == EOF) {
                            ERROR("File (%s) ended while reading\n", n.attribute("file").value());
                            return -1;
                        }
			if ((v != 0) && (crop.isIn(x, y, z)))
			    Dot(x, y, z);
		    }
	    fclose(f);
	} else {
	    pugi::xml_node node = fg_xml.find_child_by_attribute("Zone", "name", n.name());
	    if (node) {
		E(Draw(node));
	    } else {
		error("Unknown geometry element: %s\n", n.name());
		return -1;
	    }
	}
    }
    return 0;
}

/// Load data for interpolated bounce-back - binary file format has to be used
inline int Geometry::loadQIBBdata(lbRegion reg, pugi::xml_node n)
{
	
	// FILE *f = fopen(n.attribute("file").value(), "rb"); //read binary data
	 if (!n.attribute("file")) {
	error("No 'file' attribute in 'QIBB' element in xml conf\n");
	return -1;
	}
	else { 
		output( "  [QIBB] reading %s...", n.attribute("file").value());
		FILE *f = fopen(n.attribute("file").value(), "rb");
		
		if (f == NULL) {
		error("'QIBB' element: %s doesn't exists or cannot be opened\n", n.attribute("file").value());
		return -1;
		}
		
		fseek(f, 0, SEEK_END); // seek to end of file
		long int size = ftell(f); // get current file pointer
		
		int N = size/50; // LBMdataQ26 size is 50
		
		fseek(f, 0, SEEK_SET); // seek back to beginning of file
		output( "  [QIBB] size of data is %d and %d entries are stored\n", size, N );
		
		/* now proper QIBB reading takes place: */
		
		/* 1. Memory gets allocated */
		LBMdataQ26* ndata = (LBMdataQ26 *)malloc(N*sizeof(LBMdataQ26));
		/* 2. Data is read */
		int ret;
		ret = fread(ndata, N, sizeof(LBMdataQ26), f);
		
		/* end of QIBB reading */
		fclose(f);
		
		/* Testing 1. - print data
		
		for(int i=0; i < N; ++i){
		PrintLBMdataQ26(ndata[i]);
		}  */
		
		/* Testing 2. - overwrite with standard flag (for now) */
		 for(int i=0; i < N; ++i){
			QibbDot(ndata[i]);
		}
		free(ndata);
		}
    
    return 0;
	
}

//QIBB necessary for debig
void Geometry::PrintLBMdataQ26(LBMdataQ26 data){
	
	output(" [PrintLBMdataQ26] node: %d %d %d\n", data.p[0], data.p[1], data.p[2]);
	for(int i=0; i < 26; ++i)  output(" [%2d] %3d;",i+1,data.q26[i]);

	output("\n");
	
}

/// Loades Zone definition
int Geometry::loadZone(const char *name)
{
    pugi::xml_node node = fg_xml.find_child_by_attribute("Zone", "name", name);
    if (!node) {
	error("Unknown zone (in xml): %s", name);
	return -1;
    }
    E(Draw(node));
    return 0;

}

/// Loades Geometry from a XML tree
int Geometry::load(pugi::xml_node & node)
{
	output("loading geometry ...\n");
    pugi::xml_node geom_def = xml_def.child("Geometry");
    fg_xml = node;
    for (pugi::xml_node z = geom_def.first_child(); z; z = z.next_sibling()) {
	pugi::xml_attribute attr = z.attribute("name");
	if (!attr)
	    continue;
	if (node.find_child_by_attribute(z.name(), "name", attr.value()))
	    continue;
	node.prepend_copy(z);
    }
    for (pugi::xml_node n = node.first_child(); n; n = n.next_sibling()) {
	if (strcmp(n.name(), "Zone") == 0)
	    continue;
	if (strcmp(n.name(), "Type") == 0)
	    continue;
	if (strcmp(n.name(), "Mask") == 0)
	    continue;
	E(setFlag(n.name()));
	for (pugi::xml_attribute attr = n.first_attribute(); attr; attr = attr.next_attribute()) {
	    if (strcmp(attr.name(), "name") == 0) {
	        E(setZone(attr.value()));
	    } else if (strcmp(attr.name(), "mask") == 0) {
	        E(setMask(attr.value()));
	    } else {
	        
	    }
	}
	{
	    pugi::xml_attribute attr = n.attribute("zone");
	    if (attr) {
		loadZone(attr.value());
	    }
        }
	E(Draw(n));
    }
    return 0;
}

Geometry::~Geometry()
{
    debug1("[%d] Destroy geom\n", D_MPI_RANK);
    delete[]geom;
}

/// Dumps the Geometry to a vti file
void Geometry::writeVTI(char *filename)
{
    vtkFileOut vtkFile;
    if (vtkFile.Open(filename)) {
	return;
    }
    vtkFile.Init(region, "");
    vtkFile.WriteField("geom", geom);
    vtkFile.Finish();
    vtkFile.Close();
}
